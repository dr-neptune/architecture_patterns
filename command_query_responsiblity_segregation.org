#+TITLE: Command-Query Responsibility Segregation (CQRS)

Reads (queries) and writes (commands) are different, so they should be treated differently (or have their responsibilities segregated).

For the write side, our domain architectural patterns help us evolve our system over time, but the complexity we've built so far doesn't buy anything for reading data.

* Post/Redirect/Get and Command Query Segregation

With Command-Query Separation we follow one simple rule:
Functions should either modify state or answer questions, but never both.

Previously we introduced an allocate endpoint that returns a 200 OK and a batch ID. We'll change it to return a simple OK message and instead provide a new read-only endpoint to retrieve allocation state:

#+BEGIN_SRC python
@pytest.mark.usefixtures('postgres_db')
@pytest.mark.usefixtures('restart_api')

def test_happy_path_returns_202_and_batch_is_allocated():
    orderid = random_orderid()
    sku, othersku = random_sku(), random_sku("other")
    earlybatch, laterbatch, otherbatch = random_batchref(1), random_batchref(2), random_batchref(3)
    api_client.post_to_add_batch(laterbatch, sku, 100, "2011-01-02")
    api_client.post_to_add_batch(earlybatch, sku, 100, "2011-01-01")
    api_client.post_to_add_batch(otherbatch, othersku, 100, None)

    r = api_client.post_to_allocate(orderid, sku, qty=3)
    assert r.status_code == 202

    r = api_client.get_allocation(orderid)
    assert r.ok
    assert r.json() == [
        {"sku": sku, "batchref": earlybatch}
    ]

@pytest.mark.usefixtures("postgres_db")
@pytest.mark.usefixtures("restart_api")
def test_unhappy_path_returns_400_and_error_message():
    unknown_sku, orderid = random_sku(), random_orderid()
    r = api_client.post_to_allocate(
        orderid, unknown_sku, qty=20, expect_success=False
    )
    assert r.status_code == 400
    assert r.json()["message"] == f"Invalid sku {unknown_sku}"

    r = api_client.get_allocation(orderid)
    assert r.status_code == 404
#+END_SRC

and our Flask app update:

#+BEGIN_SRC python
from allocation import views

# ...

@app.route("/allocations/<orderid>", methods=["GET"])
def allocations_view_endpoint(orderid):
    uow = unit_of_work.SqlAlchemyUnitOfWork()
    result = views.allocations(orderid, uow)
    if not result:
        return "not found", 404
    return jsonify(result), 200
#+END_SRC

* Hold On to your Lunch, Folks

We can probably just add a list method to our existing repository object

#+BEGIN_SRC python
from allocation.service_layer import unit_of_work

def allocations(orderid: str, uow: unit_of_work.SqlAlchemyUnitOfWork):
    with uow:
        results = uow.session.execute(
            """
            SELECT ol.sku, b.reference
            FROM allocations AS a
            JOIN batches AS b ON a.batch_id = b.id
            JOIN order_lines AS ol ON a.orderline_id = ol.id
            WHERE ol.orderid = :orderid
            """,
            dict(orderid=orderid)
        )
    return [{"sku": sku, "batchref": batchref} for sku, batchref in results]
#+END_SRC

* Testing CQRS Views

Whatever approach we go for, we'll probably need at least one integration test.

#+BEGIN_SRC python
def test_allocations_view(sqlite_session_factory):
    uow = unit_of_work.SqlAlchemyUnitOfWork(sqlite_session_factory)

    # use the public entrypoint to our application, the messagebus
    messagebus.handle(commands.CreateBatch("sku1batch", "sku1", 50, None), uow)
    messagebus.handle(commands.CreateBatch("sku2batch", "sku2", 50, today), uow)
    messagebus.handle(commands.Allocate("order1", "sku1", 20), uow)
    messagebus.handle(commands.Allocate("order1", "sku2", 20), uow)

    # add a spurious batch in order to make sure we're getting the right ones
    messagebus.handle(commands.CreateBatch("sku1batch-later", "sku1", 50, today), uow)
    messagebus.handle(commands.Allocate("otherorder", "sku1", 30), uow)
    messagebus.handle(commands.Allocate("otherorder", "sku2", 10), uow)

    assert views.allocations("order1", uow) == [
        {"sku": "sku1", "batchref": "sku1batch"},
        {"sku": "sku2", "batchref": "sku2batch"}
    ]
#+END_SRC

* Obvious Alternative 1: Using the Existing Repository
