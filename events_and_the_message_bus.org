#+TITLE: Events and the Message Bus

It's not the obvious features that make a mess of our codebase: it's the goop around the edge. It's reporting, and permissions, and workflows that touch a zillion objects.

We'll start by doing the simplest, most expeditious thing, and talk about why this leads to a big ball of mud.
Then we'll show how to use the *Domain Events* pattern to separate side effects from our use cases, and how to use a simple *Message Bus* pattern
for triggering behavior based on those events.

* Single Responsibility Principle

Trying to stick email functionality in our (domain, service layer, web controller) layer is a violation of the *single responsibility principle*.

: Rule of thumb: if you can't describe what your function does without using words like "then" or "and" you might be violating the SRP

To solve the problem, we're going to split the orchestration into separate steps so that the different concerns don't get tangled up.

* All Aboard the Message Bus!

The patterns we will look at are Domain Events and the Message Bus.

Instead of being concerned about emails, our model will be in charge of recording events. We'll use a message bus to respond to events and invoke a new operation.

* Events are Simple Dataclasses

An event is a kind of value object. Events don't have any behavior, because they're pure data structures.

#+BEGIN_SRC python :tangle events.py
from dataclasses import dataclass

class Event:  # 1
    pass

@dataclass
class OutOfStock(Event):  # 2
    sku: str
#+END_SRC

1. Once we have a number of events, we'll find it useful to have a parent class that can store common attributes. It's also useful for type hints in our message bus
2. dataclasses are great for domain events too

* The Model Raises Events

When our domain model records a fact that happened, we say it raises an event

#+BEGIN_SRC python
def test_records_out_of_stock_event_if_cannot_allocate():
    batch = Batch("batch1", "SMALL-FORK", 10, eta=today)
    product = Product(sku="SMALL-FORK", batches=[batch])
    product.allocate(OrderLine("order1", "SMALL-FORK", 10))

    allocation = product.allocate(OrderLine("order2", "SMALL-FORK", 1))
    assert product.events[-1] == events.OutOfStock(sku="SMALL-FORK")  # 1
    assert allocation is None
#+END_SRC

1. Our aggregate will expose a new attribute called .events that will contain a list of facts about what has happened, in the form of Event objects

Here's what the model looks like on the inside:

#+BEGIN_SRC python
class Product:
    def __init__(self, sku: str, batches: List[Batch], version_number: int = 0):
        self.sku = sku
        self.batches = batches
        self.version_number = version_number
        self.events = []  # type: List[events.Event]  # 1

    def allocate(self, line: OrderLine) -> str:
        try:
            # ...
            except StopIteration:
                self.events.append(events.OutOfStock(line.sku))  # 2
                # raises OutOfStock(f"Out of stock for sku {line.sku}")  # 3
                return None
#+END_SRC

1. Here is our new .events attribute in use
2. Rather than invoking some email sending code directly, we record those events at the place they occur, using only the language of the domain
3. We're also going to stop raising an exception for the out-of-stock case. The event will do the job the exception was doing.

* The Message Bus Maps Events to Handlers
